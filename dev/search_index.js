var documenterSearchIndex = {"docs":
[{"location":"robust_po/#Robust-Portfolio-Optimization","page":"Robust PO","title":"Robust Portfolio Optimization","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Acknowledgements: Robust Formulations based on and inspired by Professor Davi M. Valladão's lectures on \"Capital Market\".","category":"page"},{"location":"robust_po/#Motivation","page":"Robust PO","title":"Motivation","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Portfolio Optimization (PO) formulations were developed to adapt to a variety of settings for decisions under uncertainty. These formulations depend on the available information of the uncertain data and the risk aversion of the decision-maker.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"The available information for many market data (e.g. stock prices, future prices, etc) have non-stationary profiles that are hard to make statistical inference on. Thus, it can be hard to find good probability distributions needed for stochastic optimization. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"One alternative approach is Robust Optimization.","category":"page"},{"location":"robust_po/#Background","page":"Robust PO","title":"Background","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Robust Optimization (RO) problems belong to the class of optimization under uncertainty problems where some problem data is uncertain (either because the decision is taken before the realization of the random event or because its observation is not available). Usual application cases for RO are when there isn’t sufficient information to derive probability distributions, but this isn’t strictly necessary. RO focuses on guaranteeing solution feasibility for any possible value of the uncertain data inside a defined Uncertainty Set. In the case where the uncertainty impacts the objective function, it guarantees optimality for the works case scenario considered in the Uncertainty Set.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Many uncertainty sets have been proposed to accommodate different levels of conservatism and data structures ([1]-[7]). A comparison of uncertainty sets to usual risk measures used in finance are included in [4] and [11].","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"A collection of recent contributions to robust portfolio strategies are outlined in [7 - 10]. Data-driven approaches to robust PO has also gained interest in recent years and can be found in [12] - for a portfolio of stocks - and [13] - for a portfolio of future contracts. The results of these studies indicate promising alternatives for the integration of uncertain data in PO.","category":"page"},{"location":"robust_po/#Problem-Definition","page":"Robust PO","title":"Problem Definition","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"A simple version of the Mean-Variance Portfolio Allocation with robust uncertainty around the estimated mean returns (posed as a quadratic convex problem):","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"    beginaligned\n        max_w quad  R \n        st quad  R = (min rw    r in Omega) \n         w  Sigma w leq V_0 * W_0\n         w in mathcalX \n    endaligned","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Maximizes the worst case portfolio return (R) and limits the portfolio variance to a maximal risk parameter (V_0) normalized by current wealth (W_0).","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Where mathcalX represents the additional constraints defined in the model by the user (e.g. a limit on maximum invested money).","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"A julia object representing this problem can be instanciated by the following command:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"formulation = PortfolioFormulation(MAX_SENSE,\n    ObjectiveTerm(ExpectedReturn(Ω)),\n    RiskConstraint(Variance(d), LessThan(V_0 * W_0)),\n)","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"where d is a Sampleable containing the estimated \\\\Sigma matrix.","category":"page"},{"location":"robust_po/#Bertsimas's-Uncertainty-Set","page":"Robust PO","title":"Bertsimas's Uncertainty Set","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"The uncertainty set proposed by Bertsimas in [6] is defined by the julia type (BudgetSet):","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Omega = left mu  middle beginarrayll\nst  quad mu_i leq hatr_i + z_i Delta_i quad forall i = 1mathcalN \nquad quad mu_i geq hatr_i - z_i Delta_i  quad forall i = 1mathcalN \nquad quad z_i geq 0 quad forall i = 1mathcalN \nquad quad z_i leq 1 quad forall i = 1mathcalN \nquad quad sum_i^mathcalN z_i leq Gamma \nendarray\nright ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"where:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"hatr: Predicted mean of returns.\nDelta: Uncertainty around mean.\nGamma: Budget (sometimes interpreted as number of assets in worst case).\nSigma: Predicted covariance of returns.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"The equivalent JuMP expression defining the worst case return (R) considering this uncertainty set can be constructed by the function calculate_measure!(measure::ExpectedReturn{BudgetSet,WorstCase}, w). In this case, R in the described uncertainty set is defined by the following primal problem:  ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"beginaligned\nmin_mu z quad  mu  w \nst quad  mu_i leq hatr_i + z_i Delta_i quad forall i = 1mathcalN quad  pi^-_i \n mu_i geq hatr_i - z_i Delta_i  quad forall i = 1mathcalN quad  pi^+_i \n z_i geq 0 quad forall i = 1mathcalN \n z_i leq 1 quad forall i = 1mathcalN quad  theta_i \n sum_i^mathcalN z_i leq Gamma quad  lambda \nendaligned","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"However, the above equations cannot be directly incorporated in the upper-level problem since no of-the-shelf solver can solve the resulting bi-level (\"MinMax\") optimization problem. Moreover, our case becomes even harder given the variable multiplication of the upper-level variable (w) with the lower-level decision variable (mu) in the objective function of the primal problem. The solution to this issue is to use of the following equivalent dual problem:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"beginaligned\nmax_lambda pi^- pi^+ theta quad   sum_i^mathcalN (hatr_i (pi^+_i - pi^-_i) - theta_i ) - Gamma lambda\nst  quad  w_i = pi^+_i - pi^-_i  quad forall i = 1mathcalN \n  Delta_i (pi^+_i + pi^-_i) - theta_i leq lambda quad forall i = 1mathcalN \n lambda geq 0   pi^- geq 0   pi^+ geq 0   theta geq 0 \nendaligned","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Moreover, to avoid having a bi-level optimization problem, we replace the lower-level problem by its objective function expression and enforce the dual constraints in the upper-level problem, defining a lower bound for the optimal value (which will be exact if the upper-level problem requires). ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Finally, for instance, the resulting problem becomes:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"beginaligned\nmax_w lambda pi^- pi^+ theta quad  R \nst quad  R = sum_i^mathcalN (hatr_i (pi^+_i pi^-_i) - theta_i ) - Gamma lambda \n w_i = pi^+_i - pi^-_i  quad forall i = 1mathcalN \n  Delta_i (pi^+_i + pi^-_i) - theta_i leq lambda quad forall i = 1mathcalN \n w  Sigma w  leq V_0 * W_0 \n lambda geq 0   pi^- geq 0   pi^+ geq 0   theta geq 0 \n w in mathcalX \nendaligned","category":"page"},{"location":"robust_po/#Uncertainty-Set-Vizualization-and-Special-Case-(Soyster's-Uncertainty-Set)","page":"Robust PO","title":"Uncertainty Set Vizualization and Special Case (Soyster's Uncertainty Set)","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"In order to visualize Bertsimas's uncertainty set, it's useful to plot the case with only two assets. For instance, when the budget parameter is equal to one (Gamma = 1) the resulting feasible region of the uncertaity set only allows one asset to be in its extreme value:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"On the other hand, when the budget parameter is equal to the number of assets (Gamma = 2), the uncertainty set becomes similar to the one proposed by Soyster in [1], i.e. box uncertainty:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/#Building-Intuition-with-Efficient-Frontiers","page":"Robust PO","title":"Building Intuition with Efficient Frontiers","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Understanding the impacts on the final optimal portfolio given the uncertainty set is not trivial, but some easy analysis can help. One useful analysis is to plot the Efficient Frontier (EF) (a.k.a Pareto Frontier) for our optimization problems, which shows what are the optimal porfolios given our objective and constraints.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"If we plot the EF for the classic mean-variance problem (Markoviz) as well as the closest robust portfolios (e.g. Bertsimas and Soyster), we can see that by expanding our uncertainty set (and consequently restricting further our problem), we get sub-optimal solutions for the non-robust problem:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Its also useful to see the EF for the respective robust problems since they have their own efficient frontier:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Notwithstanding the importance of looking at EF for specific objectives, its more useful to see the possible returns the portfolio from a certain strategy might have if we allow the asset returns to vary inside the uncertainty sets. For instance, lets allow returns to vary inside Bertsimas' uncertainty set and see the consequences for Markowitz optimal portfolios and Bertsimas' optimal portfolios:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Now we can cleary see the trade-off the robust portfolio is providing: a lower avarage return for a smaller range of possible portfolio return that is contained in the range of the non-robust counterpart.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Moreover, if we allow returns to vary inside Soyster's uncertainty set, we get the following frontiers:","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"(Image: )","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"Once again we get a lower avarage return for a smaller range of possible portfolio return that is contained in the range of the less-robust counterpart.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"PS.: Code in examples/test_effi_robust.jl.","category":"page"},{"location":"robust_po/#Comming-Soon","page":"Robust PO","title":"Comming Soon","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"TODO: Ben-Tal's uncertainty set (EllipticalSet)","category":"page"},{"location":"robust_po/#References","page":"Robust PO","title":"References","text":"","category":"section"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[1] Soyster, A.L. Convex programming with set-inclusive constraints and applications to inexact linear programming. Oper. Res. 1973, 21, 1154–1157.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[2] Ben-Tal, A. e Nemirovski, A. (1999). Robust solutions of uncertain linear programs. Operations research letters, 25(1):1–13. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[3] Ben-Tal, A. e Nemirovski, A. (2000). Robust solutions of linear programming problems contaminated with uncertain data. Mathematical programming, 88(3):411–424. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[4] Bertsimas, D. e Brown, D. B. (2009). Constructing uncertainty sets for robust linear optimization. Operations research, 57(6):1483–1495. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[5] Bertsimas, D. e Pachamanova, D. (2008). Robust multiperiod portfolio management in the presence of transaction costs. Computers & Operations Research, 35(1):3–17. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[6] Bertsimas, D. e Sim, M. (2004). The price of robustness. Operations research, 52(1):35–53. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[7] Bertsimas, D. e Sim, M. (2006). Tractable approximations to robust conic optimization problems. Mathematical programming, 107(1-2):5–36. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[8] Fabozzi, F. J., Huang, D., e Zhou, G. (2010). Robust portfolios: contributions from operations research and finance. Annals of Operations Research, 176(1):191–220. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[9] Fabozzi, F. J., Kolm, P. N., Pachamanova, D. A., e Focardi, S. M. (2007). Robust portfolio optimization. Journal of Portfolio Management, 33(3):40. ","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[10] Kim, J. H., Kim, W. C., e Fabozzi, F. J. (2014). Recent developments in robust portfolios with a worst-case approach. Journal of Optimization Theory and Applications, 161(1):103–121.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[11] Natarajan, K., Pachamanova, D., e Sim, M. (2009). Constructing risk measures from uncertainty sets. Operations research, 57(5):1129–1141.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[12] Fernandes, B., Street, A., ValladA˜ £o, D., e Fernandes, C. (2016). An adaptive robust portfolio optimization model with loss constraints based on data-driven polyhedral uncertainty sets. European Journal of Operational Research, 255(3):961 – 970. ISSN 0377-2217. URL.","category":"page"},{"location":"robust_po/","page":"Robust PO","title":"Robust PO","text":"[13] Futures Contracts Portfolio Selection via Robust Data Driven Optimization publication date Aug 9, 2018  publication descriptionL SBPO, 2018, Rio de Janeiro. Anais do L SBPO, 2018. v. 1. URL.","category":"page"},{"location":"api/#Api","page":"API","title":"Api","text":"","category":"section"},{"location":"api/#PortfolioOpt","page":"API","title":"PortfolioOpt","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PortfolioOpt]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [PortfolioOpt]","category":"page"},{"location":"api/#PortfolioOpt.AmbiguitySet","page":"API","title":"PortfolioOpt.AmbiguitySet","text":"AmbiguitySet\n\nAlias for Union{CenteredAmbiguitySet, ContinuousMultivariateSampleable}\n\n\n\n\n\n","category":"type"},{"location":"api/#PortfolioOpt.BudgetSet","page":"API","title":"PortfolioOpt.BudgetSet","text":"BudgetSet{T<:Real, D<:ContinuousMultivariateSampleable} <: CenteredAmbiguitySet{T,D}\n\nBertsimas's uncertainty set:\n\nleft mu  middle beginarrayll\nst  quad mu_i leq hatr_i + z_i Delta_i quad forall i = 1mathcalN \nquad quad mu_i geq hatr_i - z_i Delta_i  quad forall i = 1mathcalN \nquad quad z_i geq 0 quad forall i = 1mathcalN \nquad quad z_i leq 1 quad forall i = 1mathcalN \nquad quad sum_i^mathcalN z_i leq Gamma \nendarray\nright \n\nAttributes:\n\nd::Sampleable{Multivariate, Continous}: The parent distribution with an uncertain mean\nΔ::Array{Float64,1}: Uncertainty around mean. (default: std(d) / 5)\nΓ::Float64: Number of assets in worst case. (default: 0.1 * length(d))\n\nReferences:\n\nBertsimas, D. e Sim, M. (2004). The price of robustness. Operations research, 52(1):35–53.\n\n\n\n\n\n","category":"type"},{"location":"api/#PortfolioOpt.CenteredAmbiguitySet","page":"API","title":"PortfolioOpt.CenteredAmbiguitySet","text":"CenteredAmbiguitySet\n\nDefines the ambiguity related to the distribution of a random variable, often used in Robust Optimization (RO) and Distributionally Robust Optimization (DRO) problems. It represents a bounded infinite set of distributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#PortfolioOpt.DuWassersteinBall","page":"API","title":"PortfolioOpt.DuWassersteinBall","text":"DuWassersteinBall <: CenteredAmbiguitySet\n\nleft r   middle beginarrayll\nst  quad d_w(P hatP_N) leq epsilon \nquad quad  xi  leq Lambda \nquad quad xi 0 + 0_m x 1 Lambda in K \nquad quad K = omega pi in R^m x R pi geq omega^* \nendarray\nright \n\nAtributes:\n\nd::ContinuousMultivariateSampleable: Samples from the parent distribution\nϵ::Float64: Wasserstein distance from sampled distribution (has to be greater than 0). (default: 0.01)\nΛ::Float64: Uncertainty around sampled values (has to be greater than 0). (default: maximum(d))\n\nReferences:\n\nNingNing paper on Wasserstein DRO (Corollary 1-3): https://ieeexplore.ieee.org/abstract/document/9311154\n\n\n\n\n\n","category":"type"},{"location":"api/#PortfolioOpt.EllipticalSet","page":"API","title":"PortfolioOpt.EllipticalSet","text":"EllipticalSet <: CenteredAmbiguitySet{T,D}\n\nleft mu  middle beginarrayll\nst  quad sqrt(hatr - mu)  Sigma^-1 (hatr - mu) leq delta \nendarray\nright \n\nAtributes:\n\nd::Sampleable{Multivariate, Continous}: The parent distribution with an uncertain mean\nΔ::Array{Float64,1}: Uniform uncertainty around mean. (default: 0.025)\n\nReferences:\n\nBen-Tal, A. e Nemirovski, A. (2000). Robust solutions of linear programming problems contaminated with uncertain data. Mathematical programming, 88(3):411–424.\n\nFor more information on how BenTal uncertainty sets are used for RO, please review the PortfolioOptimization.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"api/#PortfolioOpt.MomentUncertainty","page":"API","title":"PortfolioOpt.MomentUncertainty","text":"MomentUncertainty <: CenteredAmbiguitySet\n\nleft r   middle beginarrayll\nst  quad (mathbbE r - hatr)  Sigma^-1 (mathbbE r - hatr) leq gamma_1 \nquad quad mathbbE  (r - hatr)  (r - hatr)  leq gamma_2 Sigma \nendarray\nright \n\nAtributes:\n\nd::Sampleable{Multivariate, Continous}: The parent distribution with an uncertain mean\nγ1::Float64: Uniform uncertainty around the mean (has to be greater than 0). (default: std(dist) / 5)\nγ2::Float64: Uncertainty around the covariance (has to be greater than 1). (default: 3.0)\n\nReferences:\n\nDelage paper on moment uncertainty (implemented): https://www.researchgate.net/publication/220244490DistributionallyRobustOptimizationUnderMomentUncertaintywithApplicationtoData-Driven_Problems\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimalBids.change_bids!-Tuple{VolumeMarket, Model, Any}","page":"API","title":"OptimalBids.change_bids!","text":"change_bids!(market::VolumeMarket, model::JuMP.Model, decision_variables)\n\nSolves optimization model and set new bids to optimal values of the decision_variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{N}, Tuple{α}, Tuple{S}, Tuple{ConditionalExpectedReturn{α, N, S, EstimatedCase}, Any}} where {S<:Distributions.Sampleable{Distributions.Multivariate, Distributions.Continuous}, α, N}","page":"API","title":"PortfolioOpt.calculate_measure!","text":"conditionalexpectation = -cvar = -expectedshortfall\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{R}, Tuple{N}, Tuple{S}, Tuple{ConditionalExpectedReturn{Inf, N, S, R}, Any}} where {S<:Distributions.Sampleable{Distributions.Multivariate, Distributions.Continuous}, N, R}","page":"API","title":"PortfolioOpt.calculate_measure!","text":"calculate_measure!(measure::ConditionalExpectedReturn{Inf,N,S,R}, w)\n\nReturns worst case return in the convex hull uncertainty set, defined by the following dual problem: \n\n    max_theta quad  theta \n    st  quad theta leq r_s  w quad forall s = 1mathcalS \n\nFurther information:\n\nFernandes, B., Street, A., ValladA˜ £o, D., e Fernandes, C. (2016). An adaptive robust portfolio optimization model with loss constraints based on data-driven polyhedral uncertainty sets. European Journal of Operational Research, 255(3):961 – 970. ISSN 0377-2217. URL.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{R}, Tuple{S}, Tuple{U}, Tuple{ExpectedUtility{U, S, R}, Any}} where {U<:PieceWiseUtility, S<:MomentUncertainty, R<:WorstCase}","page":"API","title":"PortfolioOpt.calculate_measure!","text":"calculate_measure!(measure::ExpectedReturn{MomentUncertainty,WorstCase}, w)\n\nReturns worst case utility return (WCR) under distribution uncertainty defined by MomentUncertainty ambiguity set (MomentUncertainty).\n\nArguments:\n\nw: portfolio optimization investment variable (\"weights\").\ns::MomentUncertainty: Struct containing atributes of MomentUncertainty ambiguity set.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{R}, Tuple{T}, Tuple{S}, Tuple{ConditionalExpectedReturn{1.0, T, S, R}, Any}} where {S<:DuWassersteinBall, T, R}","page":"API","title":"PortfolioOpt.calculate_measure!","text":"objectivefunction!(model, f, ambiguityset, fee_rates, samples)\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{S}, Tuple{ExpectedReturn{S, WorstCase}, Any}} where S<:BudgetSet","page":"API","title":"PortfolioOpt.calculate_measure!","text":"calculate_measure!(measure::ExpectedReturn{BudgetSet,WorstCase}, w)\n\nReturns worst case return (WCR) in BudgetSet's uncertainty set (BudgetSet).\n\nFor further reading:\n\nBudgetSet' paper: BudgetSet, D. e Sim, M. (2004). The price of robustness. Operations research, 52(1):35–53.\nOriginal implementation from: https://github.com/andrewrosemberg/PortfolioOpt.jl.\n\nWCR is defined by the following primal problem: \n\nbeginaligned\nmin_mu z quad  mu  w \nst quad  mu_i leq hatr_i + z_i Delta_i quad forall i = 1mathcalN quad  pi^-_i \n mu_i geq hatr_i - z_i Delta_i  quad forall i = 1mathcalN quad  pi^+_i \n z_i geq 0 quad forall i = 1mathcalN \n z_i leq 1 quad forall i = 1mathcalN quad  theta_i \n sum_i^mathcalN z_i leq Gamma quad  lambda \nendaligned\n\nWhich is equivalent to the following dual problem:\n\nbeginaligned\nmax_lambda pi^- pi^+ theta quad  sum_i^mathcalN (hatr_i (pi^+_i - pi^-_i) - theta_i ) - Gamma lambda\nst quad   w_i = pi^+_i - pi^-_i  quad forall i = 1mathcalN \n  Delta_i (pi^+_i + pi^-_i) - theta_i leq lambda quad forall i = 1mathcalN \n lambda geq 0   pi^- geq 0   pi^+ geq 0   theta geq 0 \nendaligned\n\nTo avoid solving an optimization problem we enforece the dual constraints in  the upper level problem and return the objective expression (a lower bound of the optimum).\n\nArguments:\n\nw: portfolio optimization investment variable (\"weights\").\ns::BudgetSet: Struct containing atributes of BudgetSet's uncertainty set.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.calculate_measure!-Union{Tuple{S}, Tuple{ExpectedReturn{S, WorstCase}, Any}} where S<:EllipticalSet","page":"API","title":"PortfolioOpt.calculate_measure!","text":"calculate_measure!(measure::ExpectedReturn{EllipticalSet,WorstCase}, w)\n\nReturns worst case return (WCR) in EllipticalSet's uncertainty set (EllipticalSet).\n\nWCR is defined by the following primal problem: \n\nbeginaligned\nmin_mu quad  mu  w \nst quad  Σ^-frac12 (mu - hatr)  leq delta quad  theta \nendaligned\n\nWhich is equivalent to the following dual problem:\n\nbeginaligned\nmax_theta quad   w  hatr - theta delta \nst quad  Σ^frac12  w  leq theta \nendaligned\n\nTo avoid solving an optimization problem we enforece the dual constraints in  the upper level problem and return the objective expression (a lower bound of the optimum).\n\nArguments:\n\nw: portfolio optimization investment variable (\"weights\").\ns:: EllipticalSet: Struct containing atributes of EllipticalSet's uncertainty set.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.equal_weights-Tuple{Any}","page":"API","title":"PortfolioOpt.equal_weights","text":"Equal weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.market_model-Union{Tuple{N}, Tuple{T}, Tuple{VolumeMarket{T, N}, Any}} where {T, N}","page":"API","title":"PortfolioOpt.market_model","text":"market_model(market::VolumeMarket{T,N}, optimizer_factory::Function) -> JuMP.Model, Vector{VariableRef}\n\nCreates a JuMP model with appropriate PO variable and constraints:     - Investment vector of variables w (portfolio weights if budget = 1).     - Invested monney should be lower budget.\n\nReturns the model and the reference to the vector of decision variables (length N).\n\nAditional arguments:\n\noptimizer_factory: callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer`.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.max_sharpe-Tuple{Any, Any, Any}","page":"API","title":"PortfolioOpt.max_sharpe","text":"Maximize sharp coefficient allocation.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.mixed_signals_predict_return","page":"API","title":"PortfolioOpt.mixed_signals_predict_return","text":"Mixed signals predictor proposed by Betina and al. Univariate\n\n\n\n\n\n","category":"function"},{"location":"api/#PortfolioOpt.sequential_backtest_market-Tuple{Function, MarketHistory, Any}","page":"API","title":"PortfolioOpt.sequential_backtest_market","text":"sequential_backtest_market(strategy_logic::Function, market_history::VolumeMarketHistory) -> Vector{Real}, Vector{Real}\n\nSimple sequential backtest functionality for strategies that return an array of invested money per asset. Ideal for statefull strategies.\n\nAPI:\n\nwealth_strategy, returns_strategy = sequential_backtest_market(market_history; date_range=date_range) \n    do market, past_returns\n    # ... Strategy definition ...\n    return investment_decision\nend\n\nArguments:\n\nstrategy_logic::Function: Function that represents the investment strategy.\nmarket_history::MarketHistory: Market history.\n\nOptional Keywork Arguments:\n\ndate_range: Dates to be simulated with corresponding entries in the market history.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestUtils","page":"API","title":"TestUtils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PortfolioOpt.TestUtils]\nPrivate = false","category":"page"},{"location":"api/#PortfolioOpt.TestUtils","page":"API","title":"PortfolioOpt.TestUtils","text":"TestUtils\n\nSome commom test utilities for portfolio optimization formulations.\n\nMainly:     - get_test_data that returns a TimeArray of prices for 6 assets.\n\n\n\n\n\n","category":"module"},{"location":"api/#PortfolioOpt.TestUtils.get_test_data-Tuple{}","page":"API","title":"PortfolioOpt.TestUtils.get_test_data","text":"Get test data (Prices) from MarketData.\n\n\n\n\n\n","category":"method"},{"location":"api/#PortfolioOpt.TestUtils.mean_variance-Tuple{Any}","page":"API","title":"PortfolioOpt.TestUtils.mean_variance","text":"Mean and Variance of returns\n\n\n\n\n\n","category":"method"},{"location":"examples_so/#Example-Markowitz","page":"Example Markowitz","title":"Example Markowitz","text":"","category":"section"},{"location":"examples_so/#Empirical-Forecast","page":"Example Markowitz","title":"Empirical Forecast","text":"","category":"section"},{"location":"examples_so/","page":"Example Markowitz","title":"Example Markowitz","text":"Example of backtest with Mean-Variance strategy with a simple empirical forecaster.","category":"page"},{"location":"examples_so/","page":"Example Markowitz","title":"Example Markowitz","text":"using COSMO\nusing Distributions\nusing PortfolioOpt\nusing PortfolioOpt.TestUtils\n\n# Read Prices \nprices = get_test_data();\nnumD, numA = size(prices) # A: Assets    D: Days\n\n# Calculating returns \nreturns_series = percentchange(prices);\n\n# Backtest Parameters \nDEFAULT_SOLVER = optimizer_with_attributes(\n    COSMO.Optimizer, \"verbose\" => false, \"max_iter\" => 900000\n)\n\ndate_range = timestamp(returns_series)[100:end];\n\n# Backtest\nbacktest_results = Dict()\nbacktest_results[\"EP_markowitz_limit_var\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Parameters\n    max_std = 0.003 / market_budget(market)\n    k_back = 60\n\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Forecast\n    Σ, r̄ = mean_variance(returns[(end - k_back):end, :])\n    d = MvNormal(r̄, Σ)\n\n    # PO Formulation\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(d)),\n        RiskConstraint(SqrtVariance(d), LessThan(max_std)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_so/#GP-Forecast","page":"Example Markowitz","title":"GP Forecast","text":"","category":"section"},{"location":"examples_so/#Train-Forecast","page":"Example Markowitz","title":"Train Forecast","text":"","category":"section"},{"location":"examples_so/","page":"Example Markowitz","title":"Example Markowitz","text":"\n# Load our GP-related packages.\nusing AbstractGPs\nusing Distributions\nusing KernelFunctions\nusing LinearMixingModels\nusing LinearAlgebra\nusing KernelFunctions: MOInputIsotopicByOutputs\nusing Optim # Standard optimisation algorithms.\nusing ParameterHandling # Helper functionality for dealing with model parameters.\nusing Zygote # Algorithmic Differentiation\nusing ParameterHandling: flatten\n\n# Prep forecaster\nnum_latent_variables = 3\nU, S, _ = svd(rand(numA, num_latent_variables));\n\nflat_initial_params, unflatten = flatten((\n    var_kernel = positive(0.6),\n    λ = positive(2.5),\n    var_noise = positive(0.1),\n    H = Matrix(Orthogonal(U, Diagonal(S)))\n))\n\n# Construct a function to unpack flattened parameters and pull out the raw values.\nunpack = ParameterHandling.value ∘ unflatten\nparams = unpack(flat_initial_params)\n\nfunction build_gp(params)\n    sogp = GP(params.var_kernel * Matern52Kernel() ∘ ScaleTransform(params.λ))\n    latent_gp = independent_mogp([sogp for _ in 1:num_latent_variables]);\n    return ILMM(latent_gp, params.H);\nend\n\ndate2float(date) = float(parse(Int, (replace(string(date), \"-\" => \"\"))))\n\n# Forecast\ndates_for_training = timestamp(returns_series)[1:99]\n\nx_train = MOInputIsotopicByOutputs(date2float.(dates_for_training), numA);\ny_train = vec(values(returns_series[dates_for_training]));\n\nfunction objective(params)\n    ilmm = build_gp(params)\n    return -logpdf(ilmm(x_train, params.var_noise), y_train)\nend\n\nobjective(params)\n\n# Optimise using Optim. \ntraining_results = Optim.optimize(\n    objective ∘ unpack,\n    θ -> only(Zygote.gradient(objective ∘ unpack, θ)),\n    flat_initial_params,\n    BFGS(\n        alphaguess = Optim.LineSearches.InitialStatic(scaled=true),\n        linesearch = Optim.LineSearches.BackTracking(),\n    ),\n    Optim.Options(show_trace = true);\n    inplace=false,\n)\n\n# Extracting the final values of the parameters.\n# Should be close to truth.\nfinal_params = unpack(training_results.minimizer)\n\n# Test Predict\ndates_for_test = timestamp(returns_series)[1:120]\nnum_test = length(dates_for_test)\nx_test = MOInputIsotopicByOutputs(date2float.(dates_for_test), numA);\ny_test = vec(values(returns_series[dates_for_test]));\n\nilmm = build_gp(final_params)\nilmmx = ilmm(x_train, final_params.var_noise)\np_ilmmx = posterior(ilmmx, y_train)\np_i = p_ilmmx(x_test, 1e-6);\nmarg_pi = marginals(p_i)\n\n# plot\nusing Plots\n\nplt = Array{Any}(undef, numA);\nnum_train = 99\nfor i=1:numA\n    plt[i] = scatter(dates_for_training, y_train[num_train*(i-1)+1:num_train*(i)]; label = \"Train Data $i\", size=(900, 700), Title=\"Asset $i\");\n    plot!(plt[i], dates_for_test, mean.(marg_pi[num_test*(i-1)+1:num_test*(i)]); ribbon=std.(marg_pi[num_test*(i-1)+1:num_test*(i)]), label = \"Forecast $i\");\n    scatter!(plt[i], dates_for_test, y_test[num_test*(i-1)+1:num_test*(i)]; label = \"Test Data $i\")\nend\nplot(plt...)\n","category":"page"},{"location":"examples_so/#Run-backtest","page":"Example Markowitz","title":"Run backtest","text":"","category":"section"},{"location":"examples_so/","page":"Example Markowitz","title":"Example Markowitz","text":"\nbacktest_results[\"GP_markowitz_limit_var\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Parameters\n    max_std = 0.003 / market_budget(market)\n    k_back = 60\n\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Forecast\n    dates_for_training = timestamp(past_returns)[end-k_back:end]\n    x_train = MOInputIsotopicByOutputs(date2float.(dates_for_training), numA)\n    y_train = vec(values(past_returns[dates_for_training]))\n    x_test = MOInputIsotopicByOutputs(date2float.([ext[:date]]), numA);\n\n    ilmm = build_gp(final_params)\n    ilmmx = ilmm(x_train, final_params.var_noise)\n    p_ilmmx = posterior(ilmmx, y_train)\n    d = p_ilmmx(x_test, 1e-6)\n\n    # PO Formulation\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(d)),\n        RiskConstraint(SqrtVariance(d), LessThan(max_std)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend","category":"page"},{"location":"examples_so/#Plot","page":"Example Markowitz","title":"Plot","text":"","category":"section"},{"location":"examples_so/","page":"Example Markowitz","title":"Example Markowitz","text":"using Plots\nusing Plots.PlotMeasures\n\nplt = plot(;title=\"Culmulative Wealth\",\n    xlabel=\"Time\",\n    ylabel=\"Wealth\",\n    legend=:outertopright,\n    left_margin=10mm\n);\nfor (strategy_name, recorders) in backtest_results\n    plot!(plt, \n        axes(get_records(recorders[:wealth]), 1), get_records(recorders[:wealth]).data;\n        label=strategy_name,\n    )\nend\nplt","category":"page"},{"location":"examples_dro/#Example-Wasserstein-DRO","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"","category":"section"},{"location":"examples_dro/#No-Ambiguity","page":"Example Wasserstein DRO","title":"No Ambiguity","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"Example of backtest with Mean-Variance strategy with a simple empirical forecaster.","category":"page"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"using HiGHS\nusing Distributions\nusing PortfolioOpt\nusing PortfolioOpt.TestUtils\n\n# Read Prices \nprices = get_test_data();\nnumD, numA = size(prices) # A: Assets    D: Days\n\n# Calculating returns \nreturns_series = percentchange(prices);\n\n# Backtest Parameters \nDEFAULT_SOLVER = optimizer_with_attributes(\n    HiGHS.Optimizer, \"presolve\" => \"on\", \"time_limit\" => 60.0\n)\n\ndate_range = timestamp(returns_series)[100:end];\n\n# Backtest\nbacktest_results = Dict()\n\nbacktest_results[\"EP\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    returns = values(past_returns)\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(DeterministicSamples(returns'[:,:]))),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_dro/#NingNing-Du-Wasserstein:-fixed-budget","page":"Example Wasserstein DRO","title":"NingNing Du Wasserstein: fixed budget","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"ϵ=0.005\n\nbacktest_results[\"wasserstein_fixed_budget_$(ϵ)\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    j_robust = numD\n    \n    d = DeterministicSamples(returns'[:,:])\n    s = DuWassersteinBall(d; ϵ=ϵ)\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ConditionalExpectedReturn{WorstCase}(1.0, s, j_robust))\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n\nbacktest_results[\"wasserstein_fixed_budget_$(ϵ)\"][:wealth]\n","category":"page"},{"location":"examples_dro/#NingNing-Du-Wasserstein:-light-tail","page":"Example Wasserstein DRO","title":"NingNing Du Wasserstein: light tail","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"\nbacktest_results[\"wasserstein_light_tail\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    j_robust = numD\n    δ = 0.1\n    ϵ = log(1/δ)/j_robust\n    \n    d = DeterministicSamples(returns'[:,:])\n    s = DuWassersteinBall(d; ϵ=ϵ)\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ConditionalExpectedReturn{WorstCase}(1.0, s, j_robust))\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_dro/#NingNing-Du-Wasserstein:-risk-limit","page":"Example Wasserstein DRO","title":"NingNing Du Wasserstein: risk limit","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"\nbacktest_results[\"EP_limit_wasserstein\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    j_robust = numD\n    δ = 0.1\n    ϵ = log(1/δ)/j_robust\n    R = -0.001 / market_budget(market)\n    \n    d = DeterministicSamples(returns'[:,:])\n    s = DuWassersteinBall(d; ϵ=ϵ)\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ConditionalExpectedReturn{WorstCase}(1.0, DuWassersteinBall(d; ϵ=0.005), j_robust)),\n        RiskConstraint(ConditionalExpectedReturn{WorstCase}(1.0, s, j_robust), GreaterThan(R)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n\nbacktest_results[\"EP_limit_wasserstein\"][:wealth]\n","category":"page"},{"location":"examples_dro/#NingNing-Du-Wasserstein:-multiple-risk-limit","page":"Example Wasserstein DRO","title":"NingNing Du Wasserstein: multiple risk limit","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"PS.: Need a faster solver to run it.","category":"page"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"# ρ_max_range = 3:2:9\n\n# for ρ_max in ρ_max_range\n#    backtest_results[\"EP_limit_wasserstein_$(ρ_max)_cons\"], _ = sequential_backtest_market(\n#        VolumeMarketHistory(returns_series), date_range,\n#    ) do market, past_returns, ext\n#        # Prep\n#        numD, numA = size(past_returns)\n#        returns = values(past_returns)\n#        \n#       # Parameters\n#       j_robust = numD\n#       ϵ=0.01\n#      \n#        d = DeterministicSamples(returns'[:,:])\n#\n#        formulation = PortfolioFormulation(MAX_SENSE,\n#            ObjectiveTerm(ConditionalExpectedReturn{WorstCase}(1.0, DuWassersteinBall(d; ϵ=0.005), j_robust)),\n#            [\n#                RiskConstraint(ConditionalExpectedReturn{WorstCase}(1.0, DuWassersteinBall(d; ϵ=ϵ * ρ), j_robust), GreaterThan(R * ρ))\n#                for ρ in 1:ρ_max\n#            ]\n#        )\n#        \n#        pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n#        return pointers\n#    end\n# end\n","category":"page"},{"location":"examples_dro/#Culmulative-Plot","page":"Example Wasserstein DRO","title":"Culmulative Plot","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"using Plots\nusing Plots.PlotMeasures\n\nplt = plot(;title=\"Culmulative Wealth\",\n    xlabel=\"Time\",\n    ylabel=\"Wealth\",\n    legend=:outertopright,\n    left_margin=10mm,\n    size=(900, 600)\n);\nfor (strategy_name, recorders) in backtest_results\n    plot!(plt, \n        axes(get_records(recorders[:wealth]), 1), get_records(recorders[:wealth]).data;\n        label=strategy_name,\n    )\nend\nplt","category":"page"},{"location":"examples_dro/#CIs","page":"Example Wasserstein DRO","title":"CIs","text":"","category":"section"},{"location":"examples_dro/","page":"Example Wasserstein DRO","title":"Example Wasserstein DRO","text":"using Bootstrap\nusing Statistics\nusing DataFrames\nusing RecipesBase\nusing Intervals\n\n# Mean CIs\nn_boot = 1000\ncil = 0.95\n\nfunction bootstrap_ci(f, data, boot_method, ci_method)\n    bs = bootstrap(f, data, boot_method)\n    return confint(bs, ci_method)\nend\n\nfunction ci_dataframe(\n    metrics::AbstractArray, backtest_results\n)\n    return DataFrame(\n        map(keys(backtest_results), values(backtest_results)) do strategy_name, recorders\n            df_row = Dict{Symbol,Any}(\n                Symbol(metric) => Interval(\n                    bootstrap_ci(metric, get_records(recorders[:returns]).data, BasicSampling(n_boot), BasicConfInt(cil))[1][2:3]...\n                ) for metric in metrics\n            )\n            df_row[:strategy] = strategy_name\n            return df_row\n        end,\n    )\nend\n\n@userplot plot_cis\n@recipe function f(plot::plot_cis; ci_df::AbstractArray)\n    ci_df = plot.args\n\n    metrics = setdiff(names(ci_df), [\"strategy\"])\n    strategy_labels = ci_df[:, :strategy]\n    num_metrics = length(metrics)\n    num_cols = floor(Int, sqrt(num_metrics))\n    num_rows = ceil(Int, num_metrics / float(num_cols))\n    layout --> (num_rows, num_cols)\n\n    ys = 1:0.1:(1 + (0.1) * (size(ci_df, 1)-1))\n    yticks --> (ys, strategy_labels)\n    ylims --> (0.9, ys[end] + 0.1)\n    xrotation --> 45\n\n    for (i, col) in enumerate(Symbol.(metrics))\n        title := col\n        label := \"\"\n        subplot := i\n        @series begin\n            ci_df[:, col], ys\n        end\n    end\nend\n\nfunction expected_shortfall(returns; risk_level::Real=0.05)\n    last_index = floor(Int, risk_level * length(returns))\n    return -mean(partialsort(returns, 1:last_index))\nend\n\nfunction conditional_sharpe(returns; risk_level::Real=0.05)\n    cvar = - expected_shortfall(returns; risk_level=risk_level)\n\n    r̄ = mean(returns)\n\n    return r̄ ./ (r̄ .- cvar)\nend\n\nci_df = ci_dataframe([mean, expected_shortfall, conditional_sharpe], backtest_results)\nplt = plot(plot_cis(ci_df),\n    size=(900, 600)\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PortfolioOpt","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#99DDFF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/andrewrosemberg/PortfolioOpt.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star andrewrosemberg/PortfolioOpt.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#PortfolioOpt","page":"Home","title":"PortfolioOpt","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple package with Portfolio Optimization (PO) formulations using JuMP.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The current package is unregistered so you will need to add it as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add https://github.com/andrewrosemberg/PortfolioOpt.jl.git ","category":"page"},{"location":"#PO-Strategies","page":"Home","title":"PO Strategies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionalities of this package are implementations of risk measures (type PortfolioRiskMeasure) of the random variable representing the next period portfolio return (R = w'r). These are used to define the objective's terms (type ObjectiveTerm) and risk constraints (type RiskConstraint) of a PO formulation (type PortfolioFormulation). As with realistic applications, the decision maker might only have limited information about the individual asset returns, so these can be described with ambiguity sets (type AmbiguitySet) - a general object containing some limited information of the asset returns' random variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently acceptable AmbiguitySets are all CenteredAmbiguitySets, i.e. centered around a (usually Continuous) Multivariate Sampleable. E.g. :","category":"page"},{"location":"","page":"Home","title":"Home","text":"Point distributions (type Dirac) if the decision maker has absolute certainty of the PO returns;\nAny continuous multivariate distribution (type Sampleable{Multivariate, Continuous}) if the decision maker can confidently estimate the distribution for the next period's returns;\nDistributionally robust ambiguity sets if a set of distributions are equally likely to be the true distribution:\ntype MomentUncertainty;\nRobust uncertainty sets if the decision maker can only infer the support of the true distribution (also viewed as distributionally robust ambiguity sets containting just single point distributions):\ntype BudgetSet,\ntype EllipticalSet.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently implemented PortfolioRiskMeasures are: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expected return (ExpectedReturn);\nVariance;\nSquare root of the portfolio variance (SqrtVariance);\nConditional expected return (ConditionalExpectedReturn) - also called Conditional Value at Risk (CVAR) or (Expected Shortfall);\nExpected utility (ExpectedUtility) which computes the expected value of a specified (hopefully concave) utility function (ConcaveUtilityFunction):\nthe only implemented one is the piece-wise concave utility function PieceWiseUtility.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given that AmbiguitySets might be sets of distributions, it is necessary to determine which distribution to use in the definition of the PortfolioRiskMeasure. This choice can be imposed by the user through their level of robustness (type Robustness):","category":"page"},{"location":"","page":"Home","title":"Home","text":"EstimatedCase if dealing with CenteredAmbiguitySets and the user doesn't want to add any robustness (default);\nWorstCase if the decision maker wants to use the worst case distribution in the ambiguity set.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The PortfolioRiskMeasures can be used to define both the RiskConstraints and the ObjectiveTerms in a PortfolioFormulation that can be parsed into details of a JuMP.Model using the portfolio_model! function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, ObjectiveTerms can also be ConeRegularizers defined by a cone set (e.g. norm-2) and a linear transformation (default Identity).","category":"page"},{"location":"#VolumeMarket","page":"Home","title":"VolumeMarket","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The portfolio_model! modifies an existing model JuMP.Model with decision variables already created and which, ideally, are already bounded by budget and bound constraints. In order to help users define market constraints, fees and clearing processess, this package also implements an interface with OptimalBids.jl (a framework for working with generic markets) through a simple market type called VolumeMarket.","category":"page"},{"location":"","page":"Home","title":"Home","text":"VolumeMarket represents market models that only allow the strategic agent to bid at market price, thus their decision is restricted to the amount/volume traded of each of the available assets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current implementation allows the user to specify:","category":"page"},{"location":"","page":"Home","title":"Home","text":"budget::Real: Total amount of resources/volume that can be invested (usually the sum the vector of individual invested amounts or the 1-norm of it);\nvolume_fee::Real: Cost per unit of volume invested;\nallow_short_selling::Bool: If true allows decision variables to be negative; \nrisk_free_rate::Real: Risk free return (known return of the money not invested).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once an instance of a VolumeMarket is defined, one can call market_model to create a JuMP.Model with the equivalent constraints, objective terms and variables created. Moreover, after the strategic objective terms and constraints are added on top of this model, it can be passed to the change_bids! together with the VolumeMarket object to modify the volume_bids::Vector{Real}. Alternatively, change_bids! can receive the already calculated bids (if chosen elsewhere) or even just the PortfolioFormulation, leaving the work of creating the JuMP.Model and adding all constraints and objective terms (market based or strategy based) to this function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A market with already defined strategic bids, i.e. volume_bids, can be cleared using the function clear_market! that receives the VolumeMarket and the clearing_prices::Vector{Real}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To help backtesting, a type VolumeMarketHistory was created to contain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"market::VolumeMarket: The underlying market specifications;\nhistory_clearing_prices: The vector of vectors representing the historical returns for all assets with index vector timestamp;\nhistory_risk_free_rates: The vector of risk-free rates with index vector timestamp;\ntimestamp: timestamps indexing the historical asset and risk-free returns;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instances of VolumeMarketHistory are the input of sequential_backtest_market: a function that provides a basic backtest using provided strategy and VolumeMarketHistory for a specified date_range (that needs to have the same eltype as timestamp).","category":"page"},{"location":"#Extras","page":"Home","title":"Extras","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some benchmarks are available as \"End-to-End\" functions that receive parameters as inputs and output the weights of a portfolio summing up to the maximum wealth defined in the parameters. These are mainly simple rules or analytical solutions to simple PO formulations:      - max_sharpe      - equal_weights ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Normally, this package won't focus nor make available forecasting functionalities, but, as an exception, there is one univariate point-prediction forecasting function exported: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"mixed_signals_predict_return","category":"page"},{"location":"#TestUtils","page":"Home","title":"TestUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As an extra, some testing utilities are available through the submodule called TestUtils:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_test_data that returns a TimeArray of Prices for 6 assets.\nmean_variance","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"robust_po.md\", \"examples.md\", \"api.md\"]","category":"page"},{"location":"examples_ro/#Example-Betina","page":"Example Betina","title":"Example Betina","text":"","category":"section"},{"location":"examples_ro/#Empirical-Forecast","page":"Example Betina","title":"Empirical Forecast","text":"","category":"section"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"Example of backtest with Mean-Variance strategy with a simple empirical forecaster.","category":"page"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"using HiGHS\nusing Distributions\nusing PortfolioOpt\nusing PortfolioOpt.TestUtils\n\n# Read Prices \nprices = get_test_data();\nnumD, numA = size(prices) # A: Assets    D: Days\n\n# Calculating returns\nreturns_series = percentchange(prices);\n\n# Backtest Parameters\nDEFAULT_SOLVER = optimizer_with_attributes(\n    HiGHS.Optimizer, \"presolve\" => \"on\", \"time_limit\" => 60.0\n)\n\ndate_range = timestamp(returns_series)[100:end];\n\n# Backtest\nbacktest_results = Dict()\n\nbacktest_results[\"EP_limit_betina\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    k_back = 30\n    j_robust = 25\n    R = -0.015 / market_budget(market)\n\n    # Forecast\n    Σ, r̄ = mean_variance(returns[(end - k_back):end, :])\n    d = MvNormal(r̄, Σ)\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(d)),\n        RiskConstraint(ConditionalExpectedReturn{WorstCase}(Inf, DeterministicSamples(returns'[:,:]), j_robust), GreaterThan(R)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_ro/#Mixed-Signals-Forecast","page":"Example Betina","title":"Mixed Signals Forecast","text":"","category":"section"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"\nbacktest_results[\"mixed_signals_limit_betina\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    j_robust = 25\n    R = -0.015 / market_budget(market)\n    num_train = 20\n    kst = 14\n    klt = 30\n    kmom = 20\n    Q = 2\n\n    # Forecast\n    r̄ = zeros(numA)\n    for i in 1:numA\n        r̄[i] = mixed_signals_predict_return(\n            returns[:, i], num_train, kst, klt, kmom, Q\n        )\n    end\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(Dirac(r̄))),\n        RiskConstraint(ConditionalExpectedReturn{WorstCase}(Inf, DeterministicSamples(returns'[:,:]), j_robust), GreaterThan(R)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_ro/#Xgboost-Forecast","page":"Example Betina","title":"Xgboost Forecast","text":"","category":"section"},{"location":"examples_ro/#Train-trees","page":"Example Betina","title":"Train trees","text":"","category":"section"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"using XGBoost\n\n# Forecast\nk_back = 30\ndates_for_training = timestamp(returns_series)[1:99]\nprep_x(returns, k_back) = reshape(returns[end-k_back+1:end, :], 1, :)\n\nbst_forecasters = Array{Any}(undef, numA)\nfor i in 1:numA\n    x_train = Matrix(vcat([prep_x(values(returns_series[dates_for_training[1:t-1]]), k_back) for t = k_back+1:length(dates_for_training)]...))\n    y_train = values(returns_series[k_back+1:length(dates_for_training)])[:,i]\n\n    num_round = 2\n    bst_forecasters[i] = xgboost(x_train, num_round, label = y_train, eta = 1, max_depth = 2)\nend\n\npred = predict(bst_forecasters[2], prep_x(values(returns_series[timestamp(returns_series)[1:100]]), k_back))\n","category":"page"},{"location":"examples_ro/#backtest","page":"Example Betina","title":"backtest","text":"","category":"section"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"\nbacktest_results[\"xgboost_limit_betina\"], _ = sequential_backtest_market(\n    VolumeMarketHistory(returns_series), date_range,\n) do market, past_returns, ext\n    # Prep\n    numD, numA = size(past_returns)\n    returns = values(past_returns)\n    \n    # Parameters\n    j_robust = 25\n    R = -0.015 / market_budget(market)\n    k_back = 30\n\n    # Forecast\n    r̄ = zeros(numA)\n    for i in 1:numA\n        r̄[i] = predict(bst_forecasters[i], prep_x(values(past_returns), k_back))[1]\n    end\n\n    formulation = PortfolioFormulation(MAX_SENSE,\n        ObjectiveTerm(ExpectedReturn(Dirac(r̄))),\n        RiskConstraint(ConditionalExpectedReturn{WorstCase}(Inf, DeterministicSamples(returns'[:,:]), j_robust), GreaterThan(R)),\n    )\n    \n    pointers = change_bids!(market, formulation, DEFAULT_SOLVER)\n    return pointers\nend\n","category":"page"},{"location":"examples_ro/#Plot","page":"Example Betina","title":"Plot","text":"","category":"section"},{"location":"examples_ro/","page":"Example Betina","title":"Example Betina","text":"using Plots\nusing Plots.PlotMeasures\n\nplt = plot(;title=\"Culmulative Wealth\",\n    xlabel=\"Time\",\n    ylabel=\"Wealth\",\n    legend=:outertopright,\n    left_margin=10mm\n);\nfor (strategy_name, recorders) in backtest_results\n    plot!(plt, \n        axes(get_records(recorders[:wealth]), 1), get_records(recorders[:wealth]).data;\n        label=strategy_name,\n    )\nend\nplt","category":"page"}]
}
